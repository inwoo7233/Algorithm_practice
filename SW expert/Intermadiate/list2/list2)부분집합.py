arr = [3,6,7,1,5,4]
n = len(arr)

# n은 어떤 집합의 원소 갯수라고 하자.

# 어떤 부분집합에 특정 원소가 들어있을지 말지는 각 원소마다 2가지 경우를 가진다.
# 이를 원소의 갯수만큼 반복한 것이다. 그럼 모든 부분집합의 경우의 수를 알 수 있다.
# 즉, 어떤 집합의 부분집합은 2의 n승 만큼 존재한다.

# 이를 활용하여 특정 집합의 부분집합을 찾을 수 있다.

# 우선 부분집합의 개수를 비트 형태로 생각해보자. 여기서 주어진 배열 arr의 경우 원소가 6개이므로
# 000000~1000000의 숫자로 대변할 수 있는 부분집합들을 가질 것이다.
for i in range(1<<n): # 이를 코드로 표현하여 for문으로 반복시킨다.
    for j in range(n): # 원소는 n개만큼 존재한다. 각 인덱스마다 해당 원소가 이번 부분집합에 들어갈지 말지를 확인한다.
        if i & (1<<j):
            # 확인할 때는 처음 반복문을 돌렸던 000000~1000000의 수가 활용된다.
            # j번째 인덱스가 j번 시프트되면서 1000 따위의 형태를 띄고, i값인 000000~1000000의 숫자와 비교된다.
            # 이 연산이 if문을 통과하려면 i값의 오른쪽부터 n번째 비트값이 1이어야만 할 것이다. (1<<j는 해당 자리를 제외하고는 모두 0이기 때문이다.)
            # 따라서 해당 자리에 넣을지 말지에 대한 경우의 연산이 모두 처리된다.
            print(arr[j], end='')
    print()
